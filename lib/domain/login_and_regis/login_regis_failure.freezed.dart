// coverage:ignore-file
// GENERATED CODE - DO NOT MODIFY BY HAND
// ignore_for_file: unused_element, deprecated_member_use, deprecated_member_use_from_same_package, use_function_type_syntax_for_parameters, unnecessary_const, avoid_init_to_null, invalid_override_different_default_values_named, prefer_expression_function_bodies, annotate_overrides, invalid_annotation_target

part of 'login_regis_failure.dart';

// **************************************************************************
// FreezedGenerator
// **************************************************************************

T _$identity<T>(T value) => value;

final _privateConstructorUsedError = UnsupportedError(
    'It seems like you constructed your class using `MyClass._()`. This constructor is only meant to be used by freezed and you are not supposed to need it nor use it.\nPlease check the documentation here for more informations: https://github.com/rrousselGit/freezed#custom-getters-and-methods');

/// @nodoc
class _$LoginRegisFailureTearOff {
  const _$LoginRegisFailureTearOff();

  _LoginRegisFailureEmpty empty() {
    return const _LoginRegisFailureEmpty();
  }

  _LoginRegisFailurepasswordInvalid passwordInvalid() {
    return const _LoginRegisFailurepasswordInvalid();
  }

  _LoginRegisFailurepasswordDidntMatch passwordDidntMatch() {
    return const _LoginRegisFailurepasswordDidntMatch();
  }

  _LoginRegisFailureinvalidEmailAddress invalidEmailAddress() {
    return const _LoginRegisFailureinvalidEmailAddress();
  }
}

/// @nodoc
const $LoginRegisFailure = _$LoginRegisFailureTearOff();

/// @nodoc
mixin _$LoginRegisFailure {
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() passwordInvalid,
    required TResult Function() passwordDidntMatch,
    required TResult Function() invalidEmailAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginRegisFailureEmpty value) empty,
    required TResult Function(_LoginRegisFailurepasswordInvalid value)
        passwordInvalid,
    required TResult Function(_LoginRegisFailurepasswordDidntMatch value)
        passwordDidntMatch,
    required TResult Function(_LoginRegisFailureinvalidEmailAddress value)
        invalidEmailAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
  }) =>
      throw _privateConstructorUsedError;
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
    required TResult orElse(),
  }) =>
      throw _privateConstructorUsedError;
}

/// @nodoc
abstract class $LoginRegisFailureCopyWith<$Res> {
  factory $LoginRegisFailureCopyWith(
          LoginRegisFailure value, $Res Function(LoginRegisFailure) then) =
      _$LoginRegisFailureCopyWithImpl<$Res>;
}

/// @nodoc
class _$LoginRegisFailureCopyWithImpl<$Res>
    implements $LoginRegisFailureCopyWith<$Res> {
  _$LoginRegisFailureCopyWithImpl(this._value, this._then);

  final LoginRegisFailure _value;
  // ignore: unused_field
  final $Res Function(LoginRegisFailure) _then;
}

/// @nodoc
abstract class _$LoginRegisFailureEmptyCopyWith<$Res> {
  factory _$LoginRegisFailureEmptyCopyWith(_LoginRegisFailureEmpty value,
          $Res Function(_LoginRegisFailureEmpty) then) =
      __$LoginRegisFailureEmptyCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoginRegisFailureEmptyCopyWithImpl<$Res>
    extends _$LoginRegisFailureCopyWithImpl<$Res>
    implements _$LoginRegisFailureEmptyCopyWith<$Res> {
  __$LoginRegisFailureEmptyCopyWithImpl(_LoginRegisFailureEmpty _value,
      $Res Function(_LoginRegisFailureEmpty) _then)
      : super(_value, (v) => _then(v as _LoginRegisFailureEmpty));

  @override
  _LoginRegisFailureEmpty get _value => super._value as _LoginRegisFailureEmpty;
}

/// @nodoc

class _$_LoginRegisFailureEmpty implements _LoginRegisFailureEmpty {
  const _$_LoginRegisFailureEmpty();

  @override
  String toString() {
    return 'LoginRegisFailure.empty()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) || (other is _LoginRegisFailureEmpty);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() passwordInvalid,
    required TResult Function() passwordDidntMatch,
    required TResult Function() invalidEmailAddress,
  }) {
    return empty();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
  }) {
    return empty?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginRegisFailureEmpty value) empty,
    required TResult Function(_LoginRegisFailurepasswordInvalid value)
        passwordInvalid,
    required TResult Function(_LoginRegisFailurepasswordDidntMatch value)
        passwordDidntMatch,
    required TResult Function(_LoginRegisFailureinvalidEmailAddress value)
        invalidEmailAddress,
  }) {
    return empty(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
  }) {
    return empty?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (empty != null) {
      return empty(this);
    }
    return orElse();
  }
}

abstract class _LoginRegisFailureEmpty implements LoginRegisFailure {
  const factory _LoginRegisFailureEmpty() = _$_LoginRegisFailureEmpty;
}

/// @nodoc
abstract class _$LoginRegisFailurepasswordInvalidCopyWith<$Res> {
  factory _$LoginRegisFailurepasswordInvalidCopyWith(
          _LoginRegisFailurepasswordInvalid value,
          $Res Function(_LoginRegisFailurepasswordInvalid) then) =
      __$LoginRegisFailurepasswordInvalidCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoginRegisFailurepasswordInvalidCopyWithImpl<$Res>
    extends _$LoginRegisFailureCopyWithImpl<$Res>
    implements _$LoginRegisFailurepasswordInvalidCopyWith<$Res> {
  __$LoginRegisFailurepasswordInvalidCopyWithImpl(
      _LoginRegisFailurepasswordInvalid _value,
      $Res Function(_LoginRegisFailurepasswordInvalid) _then)
      : super(_value, (v) => _then(v as _LoginRegisFailurepasswordInvalid));

  @override
  _LoginRegisFailurepasswordInvalid get _value =>
      super._value as _LoginRegisFailurepasswordInvalid;
}

/// @nodoc

class _$_LoginRegisFailurepasswordInvalid
    implements _LoginRegisFailurepasswordInvalid {
  const _$_LoginRegisFailurepasswordInvalid();

  @override
  String toString() {
    return 'LoginRegisFailure.passwordInvalid()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoginRegisFailurepasswordInvalid);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() passwordInvalid,
    required TResult Function() passwordDidntMatch,
    required TResult Function() invalidEmailAddress,
  }) {
    return passwordInvalid();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
  }) {
    return passwordInvalid?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (passwordInvalid != null) {
      return passwordInvalid();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginRegisFailureEmpty value) empty,
    required TResult Function(_LoginRegisFailurepasswordInvalid value)
        passwordInvalid,
    required TResult Function(_LoginRegisFailurepasswordDidntMatch value)
        passwordDidntMatch,
    required TResult Function(_LoginRegisFailureinvalidEmailAddress value)
        invalidEmailAddress,
  }) {
    return passwordInvalid(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
  }) {
    return passwordInvalid?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (passwordInvalid != null) {
      return passwordInvalid(this);
    }
    return orElse();
  }
}

abstract class _LoginRegisFailurepasswordInvalid implements LoginRegisFailure {
  const factory _LoginRegisFailurepasswordInvalid() =
      _$_LoginRegisFailurepasswordInvalid;
}

/// @nodoc
abstract class _$LoginRegisFailurepasswordDidntMatchCopyWith<$Res> {
  factory _$LoginRegisFailurepasswordDidntMatchCopyWith(
          _LoginRegisFailurepasswordDidntMatch value,
          $Res Function(_LoginRegisFailurepasswordDidntMatch) then) =
      __$LoginRegisFailurepasswordDidntMatchCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoginRegisFailurepasswordDidntMatchCopyWithImpl<$Res>
    extends _$LoginRegisFailureCopyWithImpl<$Res>
    implements _$LoginRegisFailurepasswordDidntMatchCopyWith<$Res> {
  __$LoginRegisFailurepasswordDidntMatchCopyWithImpl(
      _LoginRegisFailurepasswordDidntMatch _value,
      $Res Function(_LoginRegisFailurepasswordDidntMatch) _then)
      : super(_value, (v) => _then(v as _LoginRegisFailurepasswordDidntMatch));

  @override
  _LoginRegisFailurepasswordDidntMatch get _value =>
      super._value as _LoginRegisFailurepasswordDidntMatch;
}

/// @nodoc

class _$_LoginRegisFailurepasswordDidntMatch
    implements _LoginRegisFailurepasswordDidntMatch {
  const _$_LoginRegisFailurepasswordDidntMatch();

  @override
  String toString() {
    return 'LoginRegisFailure.passwordDidntMatch()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoginRegisFailurepasswordDidntMatch);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() passwordInvalid,
    required TResult Function() passwordDidntMatch,
    required TResult Function() invalidEmailAddress,
  }) {
    return passwordDidntMatch();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
  }) {
    return passwordDidntMatch?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (passwordDidntMatch != null) {
      return passwordDidntMatch();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginRegisFailureEmpty value) empty,
    required TResult Function(_LoginRegisFailurepasswordInvalid value)
        passwordInvalid,
    required TResult Function(_LoginRegisFailurepasswordDidntMatch value)
        passwordDidntMatch,
    required TResult Function(_LoginRegisFailureinvalidEmailAddress value)
        invalidEmailAddress,
  }) {
    return passwordDidntMatch(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
  }) {
    return passwordDidntMatch?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (passwordDidntMatch != null) {
      return passwordDidntMatch(this);
    }
    return orElse();
  }
}

abstract class _LoginRegisFailurepasswordDidntMatch
    implements LoginRegisFailure {
  const factory _LoginRegisFailurepasswordDidntMatch() =
      _$_LoginRegisFailurepasswordDidntMatch;
}

/// @nodoc
abstract class _$LoginRegisFailureinvalidEmailAddressCopyWith<$Res> {
  factory _$LoginRegisFailureinvalidEmailAddressCopyWith(
          _LoginRegisFailureinvalidEmailAddress value,
          $Res Function(_LoginRegisFailureinvalidEmailAddress) then) =
      __$LoginRegisFailureinvalidEmailAddressCopyWithImpl<$Res>;
}

/// @nodoc
class __$LoginRegisFailureinvalidEmailAddressCopyWithImpl<$Res>
    extends _$LoginRegisFailureCopyWithImpl<$Res>
    implements _$LoginRegisFailureinvalidEmailAddressCopyWith<$Res> {
  __$LoginRegisFailureinvalidEmailAddressCopyWithImpl(
      _LoginRegisFailureinvalidEmailAddress _value,
      $Res Function(_LoginRegisFailureinvalidEmailAddress) _then)
      : super(_value, (v) => _then(v as _LoginRegisFailureinvalidEmailAddress));

  @override
  _LoginRegisFailureinvalidEmailAddress get _value =>
      super._value as _LoginRegisFailureinvalidEmailAddress;
}

/// @nodoc

class _$_LoginRegisFailureinvalidEmailAddress
    implements _LoginRegisFailureinvalidEmailAddress {
  const _$_LoginRegisFailureinvalidEmailAddress();

  @override
  String toString() {
    return 'LoginRegisFailure.invalidEmailAddress()';
  }

  @override
  bool operator ==(dynamic other) {
    return identical(this, other) ||
        (other is _LoginRegisFailureinvalidEmailAddress);
  }

  @override
  int get hashCode => runtimeType.hashCode;

  @override
  @optionalTypeArgs
  TResult when<TResult extends Object?>({
    required TResult Function() empty,
    required TResult Function() passwordInvalid,
    required TResult Function() passwordDidntMatch,
    required TResult Function() invalidEmailAddress,
  }) {
    return invalidEmailAddress();
  }

  @override
  @optionalTypeArgs
  TResult? whenOrNull<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
  }) {
    return invalidEmailAddress?.call();
  }

  @override
  @optionalTypeArgs
  TResult maybeWhen<TResult extends Object?>({
    TResult Function()? empty,
    TResult Function()? passwordInvalid,
    TResult Function()? passwordDidntMatch,
    TResult Function()? invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (invalidEmailAddress != null) {
      return invalidEmailAddress();
    }
    return orElse();
  }

  @override
  @optionalTypeArgs
  TResult map<TResult extends Object?>({
    required TResult Function(_LoginRegisFailureEmpty value) empty,
    required TResult Function(_LoginRegisFailurepasswordInvalid value)
        passwordInvalid,
    required TResult Function(_LoginRegisFailurepasswordDidntMatch value)
        passwordDidntMatch,
    required TResult Function(_LoginRegisFailureinvalidEmailAddress value)
        invalidEmailAddress,
  }) {
    return invalidEmailAddress(this);
  }

  @override
  @optionalTypeArgs
  TResult? mapOrNull<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
  }) {
    return invalidEmailAddress?.call(this);
  }

  @override
  @optionalTypeArgs
  TResult maybeMap<TResult extends Object?>({
    TResult Function(_LoginRegisFailureEmpty value)? empty,
    TResult Function(_LoginRegisFailurepasswordInvalid value)? passwordInvalid,
    TResult Function(_LoginRegisFailurepasswordDidntMatch value)?
        passwordDidntMatch,
    TResult Function(_LoginRegisFailureinvalidEmailAddress value)?
        invalidEmailAddress,
    required TResult orElse(),
  }) {
    if (invalidEmailAddress != null) {
      return invalidEmailAddress(this);
    }
    return orElse();
  }
}

abstract class _LoginRegisFailureinvalidEmailAddress
    implements LoginRegisFailure {
  const factory _LoginRegisFailureinvalidEmailAddress() =
      _$_LoginRegisFailureinvalidEmailAddress;
}
